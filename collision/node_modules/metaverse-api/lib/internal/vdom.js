"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const SubsetMapping_1 = require("./SubsetMapping");
const Diff_1 = require("./Diff");
const ReplaceWholeTreeException_1 = require("./ReplaceWholeTreeException");
const deepEqual_1 = require("../utils/deepEqual");
// tslint:disable:no-console
const innerDone = Symbol('innerDone');
const outerDone = Symbol('outerDone');
let diffcount;
let foundAll = false;
/** Returns the elements conaining a .tag string property */
function filterHavingTag($) {
    return typeof $.tag === 'string';
}
/**
 * Returns element descriptors, it is an array used to identify the given node
 */
function elementDescriptors(el) {
    let output = [];
    output.push(el.tag);
    if (el.attrs) {
        if (el.attrs.key) {
            output.push(el.tag + '.' + el.attrs.key);
        }
        if (el.attrs.id) {
            output.push(el.tag + '#' + el.attrs.id);
        }
        if (el.attrs.src) {
            output.push(el.tag + '%' + el.attrs.src);
        }
    }
    return output;
}
function findUniqueDescriptors(list) {
    let uniqueDescriptors = {};
    let duplicateDescriptors = {};
    let node;
    let descriptors;
    let descriptor;
    let inUnique;
    let inDupes;
    for (let i = 0; i < list.length; i++) {
        node = list[i];
        descriptors = elementDescriptors(node);
        for (let j = 0; j < descriptors.length; j++) {
            descriptor = descriptors[j];
            inUnique = descriptor in uniqueDescriptors;
            inDupes = descriptor in duplicateDescriptors;
            if (!inUnique && !inDupes) {
                uniqueDescriptors[descriptor] = true;
            }
            else if (inUnique) {
                delete uniqueDescriptors[descriptor];
                duplicateDescriptors[descriptor] = true;
            }
        }
    }
    return uniqueDescriptors;
}
function uniqueInBoth(l1, l2) {
    let l1Unique = findUniqueDescriptors(l1);
    let l2Unique = findUniqueDescriptors(l2);
    let inBoth = {};
    let keys = Object.keys(l1Unique);
    let length = keys.length;
    let key;
    for (let i = 0; i < length; i++) {
        key = keys[i];
        if (l2Unique[key]) {
            inBoth[key] = true;
        }
    }
    return inBoth;
}
function removeDone(tree) {
    delete tree[outerDone];
    delete tree[innerDone];
    if (tree.children) {
        return tree.children.every(removeDone);
    }
    else {
        return true;
    }
}
function isEqual(e1, e2) {
    let e1Attributes;
    let e2Attributes;
    if (!['tag'].every(function (element) {
        if (e1[element] !== e2[element]) {
            return false;
        }
        return true;
    })) {
        return false;
    }
    if (Boolean(e1.attrs) !== Boolean(e2.attrs)) {
        return false;
    }
    if (Boolean(e1.children) !== Boolean(e2.children)) {
        return false;
    }
    if (e1.attrs) {
        e1Attributes = Object.keys(e1.attrs);
        e2Attributes = Object.keys(e2.attrs);
        if (e1Attributes.length !== e2Attributes.length) {
            return false;
        }
        if (!e1Attributes.every(function (attribute) {
            if (!deepEqual_1.deepEqual(e1.attrs[attribute], e2.attrs[attribute])) {
                return false;
            }
            return true;
        })) {
            return false;
        }
    }
    if (e1.children) {
        if (e1.children.filter(filterHavingTag).length !== e2.children.filter(filterHavingTag).length) {
            return false;
        }
        if (!e1.children.filter(filterHavingTag).every(function (childNode, index) {
            return isEqual(childNode, e2.children.filter(filterHavingTag)[index]);
        })) {
            return false;
        }
    }
    return true;
}
function roughlyEqual(e1, e2, uniqueDescriptors, sameSiblings, preventRecursion = false) {
    let childUniqueDescriptors;
    let nodeList1;
    let nodeList2;
    if (!e1 || !e2) {
        return false;
    }
    if (e1.tag !== e2.tag) {
        return false;
    }
    if (e1.tag in uniqueDescriptors) {
        return true;
    }
    if (e1.attrs && e2.attrs) {
        if (e1.attrs.id) {
            if (e1.attrs.id !== e2.attrs.id) {
                return false;
            }
            else {
                let idDescriptor = e1.tag + '#' + e1.attrs.id;
                if (idDescriptor in uniqueDescriptors) {
                    return true;
                }
            }
        }
        if (e1.attrs.key) {
            if (e1.attrs.key !== e2.attrs.key) {
                return false;
            }
            else {
                let keyDescriptor = e1.tag + '.' + e1.attrs.key;
                if (keyDescriptor in uniqueDescriptors) {
                    return true;
                }
            }
        }
        if (e1.attrs.src) {
            if (e1.attrs.src !== e2.attrs.src) {
                return false;
            }
            else {
                let keyDescriptor = e1.tag + '%' + e1.attrs.src;
                if (keyDescriptor in uniqueDescriptors) {
                    return true;
                }
            }
        }
    }
    if (sameSiblings) {
        return true;
    }
    nodeList1 = e1.children
        ? e1.children
            .slice()
            .filter(filterHavingTag)
            .reverse()
        : [];
    nodeList2 = e2.children
        ? e2.children
            .slice()
            .filter(filterHavingTag)
            .reverse()
        : [];
    if (nodeList1.length !== nodeList2.length) {
        return false;
    }
    if (preventRecursion) {
        return nodeList1.every(function (element, index) {
            return element.tag === nodeList2[index].tag;
        });
    }
    else {
        // note: we only allow one level of recursion at any depth. If 'preventRecursion'
        // was not set, we must explicitly force it to true for child iterations.
        childUniqueDescriptors = uniqueInBoth(nodeList1, nodeList2);
        return nodeList1.every(function (element, index) {
            return roughlyEqual(element, nodeList2[index], childUniqueDescriptors, true, true);
        });
    }
}
function cloneObj(obj) {
    //  TODO: Do we really need to clone here? Is it not enough to just return the original object?
    return JSON.parse(JSON.stringify(obj));
}
/**
 * based on https://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring#JavaScript
 */
function findCommonSubsets(c1, c2, marked1, marked2) {
    let lcsSize = 0;
    let index = [];
    let c1Length = c1.length;
    let c2Length = c2.length;
    let matches = Array.apply(null, new Array(c1Length + 1)).map(function () {
        return [];
    });
    // set up the matching table
    let uniqueDescriptors = uniqueInBoth(c1, c2);
    // If all of the elements are the same tag, id and class, then we can
    // consider them roughly the same even if they have a different number of
    // children. This will reduce removing and re-adding similar elements.
    let subsetsSame = c1Length === c2Length;
    let origin;
    let ret;
    let c1Index;
    let c2Index;
    let c1Element;
    let c2Element;
    if (subsetsSame) {
        c1.some(function (element, i) {
            let c1Desc = elementDescriptors(element);
            let c2Desc = elementDescriptors(c2[i]);
            if (c1Desc.length !== c2Desc.length) {
                subsetsSame = false;
                return true;
            }
            c1Desc.some(function (description, i) {
                if (description !== c2Desc[i]) {
                    subsetsSame = false;
                    return true;
                }
            });
            if (!subsetsSame) {
                return true;
            }
        });
    }
    // fill the matches with distance values
    for (c1Index = 0; c1Index < c1Length; c1Index++) {
        c1Element = c1[c1Index];
        for (c2Index = 0; c2Index < c2Length; c2Index++) {
            c2Element = c2[c2Index];
            if (!marked1[c1Index] &&
                !marked2[c2Index] &&
                roughlyEqual(c1Element, c2Element, uniqueDescriptors, subsetsSame)) {
                matches[c1Index + 1][c2Index + 1] = matches[c1Index][c2Index] ? matches[c1Index][c2Index] + 1 : 1;
                if (matches[c1Index + 1][c2Index + 1] >= lcsSize) {
                    lcsSize = matches[c1Index + 1][c2Index + 1];
                    index = [c1Index + 1, c2Index + 1];
                }
            }
            else {
                matches[c1Index + 1][c2Index + 1] = 0;
            }
        }
    }
    if (lcsSize === 0) {
        return undefined;
    }
    origin = [index[0] - lcsSize, index[1] - lcsSize];
    ret = new SubsetMapping_1.SubsetMapping(origin[0], origin[1]);
    ret.length = lcsSize;
    return ret;
}
/**
 * This should really be a predefined function in Array...
 */
function makeArray(n, v) {
    return Array.apply(null, new Array(n)).map(function () {
        return v;
    });
}
/**
 * Generate arrays that indicate which node belongs to which subset,
 * or whether it's actually an orphan node, existing in only one
 * of the two trees, rather than somewhere in both.
 *
 * So if t1 = <img><canvas><br>, t2 = <canvas><br><img>.
 * The longest subset is "<canvas><br>" (length 2), so it will group 0.
 * The second longest is "<img>" (length 1), so it will be group 1.
 * gaps1 will therefore be [1,0,0] and gaps2 [0,0,1].
 *
 * If an element is not part of any group, it will stay being 'true', which
 * is the initial value. For example:
 * t1 = <img><p></p><br><canvas>, t2 = <b></b><br><canvas><img>
 *
 * The "<p></p>" and "<b></b>" do only show up in one of the two and will
 * therefore be marked by "true". The remaining parts are parts of the
 * groups 0 and 1:
 * gaps1 = [1, true, 0, 0], gaps2 = [true, 0, 0, 1]
 *
 */
function getGapInformation(t1, t2, stable) {
    let gaps1 = t1.children
        ? makeArray(t1.children.filter(filterHavingTag).length, true)
        : [];
    let gaps2 = t2.children
        ? makeArray(t2.children.filter(filterHavingTag).length, true)
        : [];
    let group = 0;
    let length = stable.length;
    let i;
    let j;
    let endOld;
    let endNew;
    let subset;
    // give elements from the same subset the same group number
    for (i = 0; i < length; i++) {
        subset = stable[i];
        endOld = subset.oldValue + subset.length;
        endNew = subset.newValue + subset.length;
        for (j = subset.oldValue; j < endOld; j += 1) {
            gaps1[j] = group;
        }
        for (j = subset.newValue; j < endNew; j += 1) {
            gaps2[j] = group;
        }
        group += 1;
    }
    return {
        gaps1: gaps1,
        gaps2: gaps2
    };
}
/**
 * Find all matching subsets, based on immediate child differences only.
 */
function markSubTrees(oldTree, newTree) {
    // note: the child lists are views, and so update as we update old/newTree
    let oldChildren = oldTree.children ? oldTree.children.filter(filterHavingTag) : [];
    let newChildren = newTree.children ? newTree.children.filter(filterHavingTag) : [];
    let marked1 = makeArray(oldChildren.length, false);
    let marked2 = makeArray(newChildren.length, false);
    let subsets = [];
    let subset;
    let returnIndex = function () {
        return arguments[1];
    };
    let markBoth = function (i) {
        marked1[subset.oldValue + i] = true;
        marked2[subset.newValue + i] = true;
    };
    let subsetArray;
    do {
        subset = findCommonSubsets(oldChildren, newChildren, marked1, marked2);
        if (subset) {
            subsets.push(subset);
            subsetArray = Array.apply(null, new Array(subset.length)).map(returnIndex);
            for (let i = 0; i < subsetArray.length; i++) {
                markBoth(subsetArray[i]);
            }
        }
    } while (subset);
    return subsets;
}
class DiffDOM {
    constructor(options = {}) {
        this.options = options;
        this.debug = false;
        this.diffcap = 10; // Limit for how many diffs are accepting when debugging. Inactive when debug is false.
        this.maxDepth = false; // False or a numeral. If set to a numeral, limits the level of depth that the the diff mechanism looks for differences. If false, goes through the entire tree.
        this.maxChildCount = false; // False or a numeral. If set to a numeral, does not try to diff the contents of nodes with more children if there are more than maxChildCountDiffCount differences among child nodes.
        this.maxChildCountDiffCount = 3; // Numeral. See maxChildCount.
        this.filterOuterDiff = null;
        this.compress = false;
    }
    // ===== Create a diff =====
    diff(t1Node, t2Node) {
        diffcount = 0;
        if (this.debug) {
            this.t1Orig = t1Node;
            this.t2Orig = t2Node;
        }
        this.tracker = [];
        return this.findDiffs(t1Node, t2Node);
    }
    findDiffs(t1, t2) {
        let diffs;
        do {
            if (this.debug) {
                diffcount += 1;
                if (diffcount > this.diffcap) {
                    // tslint:disable-next-line
                    ;
                    window.diffError = [this.t1Orig, this.t2Orig];
                    throw new Error('surpassed diffcap:' + JSON.stringify(this.t1Orig) + ' -> ' + JSON.stringify(this.t2Orig));
                }
            }
            diffs = this.findNextDiff(t1, t2, []);
            if (diffs.length === 0) {
                // Last check if the elements really are the same now.
                // If not, remove all info about being done and start over.
                // Sometimes a node can be marked as done, but the creation of subsequent diffs means that it has to be changed again.
                if (!isEqual(t1, t2)) {
                    if (foundAll) {
                        console.error('Could not find remaining diffs!');
                        console.trace({ t1, t2 });
                    }
                    else {
                        foundAll = true;
                        removeDone(t1);
                        diffs = this.findNextDiff(t1, t2, []);
                    }
                }
            }
            if (diffs.length > 0) {
                foundAll = false;
                this.tracker.push(...diffs);
                this.applyVirtual(t1, diffs);
            }
        } while (diffs.length > 0);
        return this.tracker;
    }
    findNextDiff(t1, t2, route) {
        let diffs;
        let fdiffs;
        if (this.maxDepth && route.length > this.maxDepth) {
            return [];
        }
        // outer differences?
        if (!t1[outerDone]) {
            diffs = this.findOuterDiff(t1, t2, route);
            if (this.filterOuterDiff) {
                fdiffs = this.filterOuterDiff(t1, t2, diffs);
                if (fdiffs)
                    diffs = fdiffs;
            }
            if (diffs.length > 0) {
                t1[outerDone] = true;
                return diffs;
            }
            else {
                t1[outerDone] = true;
            }
        }
        // inner differences?
        if (!t1[innerDone]) {
            diffs = this.findInnerDiff(t1, t2, route);
            if (diffs.length > 0) {
                return diffs;
            }
            else {
                t1[innerDone] = true;
            }
        }
        // no differences
        return [];
    }
    findOuterDiff(t1, t2, route) {
        let diffs = [];
        let attr;
        let attr1;
        let attr2;
        let attrLength;
        let pos;
        let i;
        if (t1.tag !== t2.tag) {
            return [
                new Diff_1.Diff()
                    .setValue(types_1.Actions.action, types_1.Actions.replaceElement)
                    .setValue(types_1.Actions.oldValue, t1)
                    .setValue(types_1.Actions.newValue, cloneObj(t2))
                    .setValue(types_1.Actions.route, route)
            ];
        }
        let t1Children = t1.children.filter(filterHavingTag);
        let t2Children = t2.children.filter(filterHavingTag);
        if (this.maxChildCount &&
            t1Children &&
            t2Children &&
            t1Children.length > this.maxChildCount &&
            t2Children.length > this.maxChildCount) {
            let childNodesLength = t1Children.length < t2Children.length ? t1Children.length : t2Children.length;
            let childDiffCount = 0;
            let j = 0;
            while (childDiffCount < this.maxChildCountDiffCount && j < childNodesLength) {
                if (!isEqual(t1Children[j], t2Children[j])) {
                    childDiffCount++;
                }
                j++;
            }
            if (childDiffCount === this.maxChildCountDiffCount) {
                return [
                    new Diff_1.Diff()
                        .setValue(types_1.Actions.action, types_1.Actions.replaceElement)
                        .setValue(types_1.Actions.oldValue, cloneObj(t1))
                        .setValue(types_1.Actions.newValue, cloneObj(t2))
                        .setValue(types_1.Actions.route, route)
                ];
            }
        }
        attr1 = t1.attrs ? Object.keys(t1.attrs).sort() : [];
        attr2 = t2.attrs ? Object.keys(t2.attrs).sort() : [];
        attrLength = attr1.length;
        for (i = 0; i < attrLength; i++) {
            attr = attr1[i];
            pos = attr2.indexOf(attr);
            if (pos === -1) {
                diffs.push(new Diff_1.Diff()
                    .setValue(types_1.Actions.action, types_1.Actions.removeAttribute)
                    .setValue(types_1.Actions.route, route)
                    .setValue(types_1.Actions.name, attr));
            }
            else {
                attr2.splice(pos, 1);
                if (!deepEqual_1.deepEqual(t1.attrs[attr], t2.attrs[attr])) {
                    diffs.push(new Diff_1.Diff()
                        .setValue(types_1.Actions.action, types_1.Actions.modifyAttribute)
                        .setValue(types_1.Actions.route, route)
                        .setValue(types_1.Actions.name, attr)
                        .setValue(types_1.Actions.oldValue, t1.attrs[attr])
                        .setValue(types_1.Actions.newValue, t2.attrs[attr]));
                }
            }
        }
        attrLength = attr2.length;
        for (i = 0; i < attrLength; i++) {
            attr = attr2[i];
            diffs.push(new Diff_1.Diff()
                .setValue(types_1.Actions.action, types_1.Actions.addAttribute)
                .setValue(types_1.Actions.route, route)
                .setValue(types_1.Actions.name, attr));
        }
        return diffs;
    }
    findInnerDiff(t1, t2, route) {
        let subtrees = t1.children && t2.children ? markSubTrees(t1, t2) : [];
        let t1ChildNodes = t1.children ? t1.children.filter(filterHavingTag) : [];
        let t2ChildNodes = t2.children ? t2.children.filter(filterHavingTag) : [];
        let childNodesLengthDifference;
        let diffs = [];
        let index = 0;
        let last;
        let e1;
        let e2;
        let i;
        if (subtrees.length > 0) {
            /* One or more groups have been identified among the children of t1
             * and t2.
             */
            diffs = this.attemptGroupRelocation(t1, t2, subtrees, route);
            if (diffs.length > 0) {
                return diffs;
            }
        }
        /* 0 or 1 groups of similar child nodes have been found
         * for t1 and t2. 1 If there is 1, it could be a sign that the
         * contents are the same. When the number of groups is below 2,
         * t1 and t2 are made to have the same length and each of the
         * pairs of child nodes are diffed.
         */
        last = Math.max(t1ChildNodes.length, t2ChildNodes.length);
        if (t1ChildNodes.length !== t2ChildNodes.length) {
            childNodesLengthDifference = true;
        }
        for (i = 0; i < last; i += 1) {
            e1 = t1ChildNodes[i];
            e2 = t2ChildNodes[i];
            if (childNodesLengthDifference) {
                /* t1 and t2 have different amounts of children. Add
                 * and remove as necessary to obtain the same length */
                if (e1 && !e2) {
                    diffs.push(new Diff_1.Diff()
                        .setValue(types_1.Actions.action, types_1.Actions.removeElement)
                        .setValue(types_1.Actions.route, route.concat(index))
                        .setValue(types_1.Actions.element, e1));
                    index -= 1;
                }
                else if (e2 && !e1) {
                    diffs.push(new Diff_1.Diff()
                        .setValue(types_1.Actions.action, types_1.Actions.addElement)
                        .setValue(types_1.Actions.route, route.concat(index))
                        .setValue(types_1.Actions.element, cloneObj(e2)));
                }
            }
            /* We are now guaranteed that children e1 and e2 exist,
             * and that they can be diffed.
             */
            /* Diffs in child nodes should not affect the parent node,
             * so we let these diffs be submitted together with other
             * diffs.
             */
            if (e1 && e2) {
                diffs = diffs.concat(this.findNextDiff(e1, e2, route.concat(index)));
            }
            index += 1;
        }
        t1[innerDone] = true;
        return diffs;
    }
    // tslint:disable-next-line:prefer-function-over-method
    attemptGroupRelocation(t1, t2, subtrees, route) {
        /* Either t1.children and t2.children have the same length, or
         * there are at least two groups of similar elements can be found.
         * attempts are made at equalizing t1 with t2. First all initial
         * elements with no group affiliation (gaps=true) are removed (if
         * only in t1) or added (if only in t2). Then the creation of a group
         * relocation diff is attempted.
        */
        let gapInformation = getGapInformation(t1, t2, subtrees);
        let gaps1 = gapInformation.gaps1;
        let gaps2 = gapInformation.gaps2;
        let shortest = Math.min(gaps1.length, gaps2.length);
        let destinationDifferent;
        let toGroup;
        let group;
        let node;
        let diffs = [];
        let index1;
        let index2;
        let j;
        let t1Children = t1.children.filter(filterHavingTag);
        let t2Children = t2.children.filter(filterHavingTag);
        for (index2 = 0, index1 = 0; index2 < shortest; index1 += 1, index2 += 1) {
            if (gaps1[index2] === true) {
                node = t1Children[index1];
                diffs.push(new Diff_1.Diff()
                    .setValue(types_1.Actions.action, types_1.Actions.removeElement)
                    .setValue(types_1.Actions.route, route.concat(index2))
                    .setValue(types_1.Actions.element, cloneObj(node)));
                gaps1.splice(index2, 1);
                shortest = Math.min(gaps1.length, gaps2.length);
                index2 -= 1;
            }
            else if (gaps2[index2] === true) {
                node = t2Children[index2];
                diffs.push(new Diff_1.Diff()
                    .setValue(types_1.Actions.action, types_1.Actions.addElement)
                    .setValue(types_1.Actions.route, route.concat(index2))
                    .setValue(types_1.Actions.element, cloneObj(node)));
                gaps1.splice(index2, 0, true);
                shortest = Math.min(gaps1.length, gaps2.length);
                index1 -= 1;
            }
            else if (gaps1[index2] !== gaps2[index2]) {
                if (diffs.length > 0) {
                    return diffs;
                }
                // group relocation
                group = subtrees[gaps1[index2]];
                toGroup = Math.min(group.newValue, t1Children.length - group.length);
                if (toGroup !== group.oldValue) {
                    // Check whether destination nodes are different than originating ones.
                    destinationDifferent = false;
                    for (j = 0; j < group.length; j += 1) {
                        if (!roughlyEqual(t1Children[toGroup + j], t1Children[group.oldValue + j], {}, false, true)) {
                            destinationDifferent = true;
                        }
                    }
                    if (destinationDifferent) {
                        return [
                            new Diff_1.Diff()
                                .setValue(types_1.Actions.action, types_1.Actions.relocateGroup)
                                .setValue(types_1.Actions.groupLength, group.length)
                                .setValue(types_1.Actions.from, group.oldValue)
                                .setValue(types_1.Actions.to, toGroup)
                                .setValue(types_1.Actions.route, route)
                        ];
                    }
                }
            }
        }
        return diffs;
    }
    // ===== Apply a virtual diff =====
    /** Patches a virtual tree using a list of diffs */
    applyVirtual(tree, diffs) {
        let length = diffs.length;
        if (length === 0) {
            return true;
        }
        for (let i = 0; i < length; i++) {
            let diff = diffs[i];
            this.applyVirtualDiff(tree, diff);
        }
        return true;
    }
    /** Gets a node in the virtual tree by a route */
    // tslint:disable-next-line:prefer-function-over-method
    getFromVirtualRoute(tree, route) {
        let node = tree;
        let parentNode;
        let nodeIndex;
        let newRoute = route.slice();
        while (newRoute.length > 0) {
            const ch = node.children.filter(filterHavingTag);
            if (!ch.length) {
                return undefined;
            }
            nodeIndex = newRoute.shift();
            parentNode = node;
            node = ch[nodeIndex];
        }
        return {
            node: node,
            parentNode: parentNode,
            nodeIndex: nodeIndex
        };
    }
    /** Patches a virtual tree using a diff */
    applyVirtualDiff(tree, diff) {
        let routeInfo = this.getFromVirtualRoute(tree, diff[types_1.Actions.route]);
        let node = routeInfo && routeInfo.node;
        let parentNode = routeInfo && routeInfo.parentNode;
        let nodeIndex = routeInfo && routeInfo.nodeIndex;
        let newNode;
        // pre-diff hook
        let info = {
            diff: diff,
            node: node,
            newNode: void 0
        };
        switch (diff[types_1.Actions.action]) {
            case types_1.Actions.addElement:
                const route = diff[types_1.Actions.route].slice();
                const c = route.splice(route.length - 1, 1)[0];
                const x = this.getFromVirtualRoute(tree, route);
                if (x) {
                    node = x.node;
                    newNode = cloneObj(diff[types_1.Actions.element]);
                    newNode[outerDone] = true;
                    newNode[innerDone] = true;
                    if (!node.children) {
                        node.children = [];
                    }
                    if (c >= node.children.length) {
                        node.children.push(newNode);
                    }
                    else {
                        node.children.splice(c, 0, newNode);
                    }
                }
                break;
            case types_1.Actions.addAttribute:
                if (!node.attrs) {
                    node.attrs = {};
                }
                node.attrs[diff[types_1.Actions.name]] = diff[types_1.Actions.value];
                break;
            case types_1.Actions.modifyAttribute:
                node.attrs[diff[types_1.Actions.name]] = diff[types_1.Actions.newValue];
                break;
            case types_1.Actions.removeAttribute:
                delete node.attrs[diff[types_1.Actions.name]];
                break;
            case types_1.Actions.replaceElement:
                newNode = cloneObj(diff[types_1.Actions.newValue]);
                newNode[outerDone] = true;
                newNode[innerDone] = true;
                if (parentNode) {
                    parentNode.children[nodeIndex] = newNode;
                }
                else {
                    throw new ReplaceWholeTreeException_1.ReplaceWholeTreeException();
                }
                break;
            case types_1.Actions.relocateGroup:
                const nodeArray = node.children.splice(diff[types_1.Actions.from], diff[types_1.Actions.groupLength]).reverse();
                for (let i = 0; i < nodeArray.length; i++) {
                    node.children.splice(diff[types_1.Actions.to], 0, nodeArray[i]);
                }
                break;
            case types_1.Actions.removeElement:
                parentNode.children.splice(nodeIndex, 1);
                break;
            default:
                console.log('unknown action');
        }
        // capture newNode for the callback
        info.newNode = newNode;
        return undefined;
    }
}
exports.DiffDOM = DiffDOM;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmRvbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnRlcm5hbC92ZG9tLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsbUNBQXdDO0FBRXhDLG1EQUErQztBQUMvQyxpQ0FBNkI7QUFDN0IsMkVBQXVFO0FBQ3ZFLGtEQUE4QztBQUM5Qyw0QkFBNEI7QUFFNUIsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFBO0FBQ3JDLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQTtBQUVyQyxJQUFJLFNBQVMsQ0FBQTtBQUNiLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQTtBQUVwQiw0REFBNEQ7QUFDNUQseUJBQXlCLENBQWtCO0lBQ3pDLE9BQU8sT0FBTyxDQUFDLENBQUMsR0FBRyxLQUFLLFFBQVEsQ0FBQTtBQUNsQyxDQUFDO0FBRUQ7O0dBRUc7QUFDSCw0QkFBNEIsRUFBbUI7SUFDN0MsSUFBSSxNQUFNLEdBQWEsRUFBRSxDQUFBO0lBRXpCLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFBO0lBRW5CLElBQUksRUFBRSxDQUFDLEtBQUssRUFBRTtRQUNaLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUU7WUFDaEIsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFBO1NBQ3pDO1FBQ0QsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUNmLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQTtTQUN4QztRQUNELElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUU7WUFDaEIsTUFBTSxDQUFDLElBQUksQ0FB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T0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQTtnQkFDekIsSUFBSSxVQUFVLEVBQUU7b0JBQ2QsVUFBVSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxPQUFPLENBQUE7aUJBQ3pDO3FCQUFNO29CQUNMLE1BQU0sSUFBSSxxREFBeUIsRUFBRSxDQUFBO2lCQUN0QztnQkFDRCxNQUFLO1lBQ1AsS0FBSyxlQUFPLENBQUMsYUFBYTtnQkFDeEIsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsZUFBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUE7Z0JBQy9GLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUN6QyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtpQkFDeEQ7Z0JBQ0QsTUFBSztZQUNQLEtBQUssZUFBTyxDQUFDLGFBQWE7Z0JBQ3hCLFVBQVUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQTtnQkFDeEMsTUFBSztZQUNQO2dCQUNFLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtTQUNoQztRQUVELG1DQUFtQztRQUNuQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQTtRQUV0QixPQUFPLFNBQVMsQ0FBQTtJQUNsQixDQUFDO0NBQ0Y7QUF2ZEQsMEJBdWRDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0aW9ucywgSURpZmYgfSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHsgSVNpbXBsaWZpZWROb2RlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcydcbmltcG9ydCB7IFN1YnNldE1hcHBpbmcgfSBmcm9tICcuL1N1YnNldE1hcHBpbmcnXG5pbXBvcnQgeyBEaWZmIH0gZnJvbSAnLi9EaWZmJ1xuaW1wb3J0IHsgUmVwbGFjZVdob2xlVHJlZUV4Y2VwdGlvbiB9IGZyb20gJy4vUmVwbGFjZVdob2xlVHJlZUV4Y2VwdGlvbidcbmltcG9ydCB7IGRlZXBFcXVhbCB9IGZyb20gJy4uL3V0aWxzL2RlZXBFcXVhbCdcbi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcblxuY29uc3QgaW5uZXJEb25lID0gU3ltYm9sKCdpbm5lckRvbmUnKVxuY29uc3Qgb3V0ZXJEb25lID0gU3ltYm9sKCdvdXRlckRvbmUnKVxuXG5sZXQgZGlmZmNvdW50XG5sZXQgZm91bmRBbGwgPSBmYWxzZVxuXG4vKiogUmV0dXJucyB0aGUgZWxlbWVudHMgY29uYWluaW5nIGEgLnRhZyBzdHJpbmcgcHJvcGVydHkgKi9cbmZ1bmN0aW9uIGZpbHRlckhhdmluZ1RhZygkOiBJU2ltcGxpZmllZE5vZGUpIHtcbiAgcmV0dXJuIHR5cGVvZiAkLnRhZyA9PT0gJ3N0cmluZydcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGVsZW1lbnQgZGVzY3JpcHRvcnMsIGl0IGlzIGFuIGFycmF5IHVzZWQgdG8gaWRlbnRpZnkgdGhlIGdpdmVuIG5vZGVcbiAqL1xuZnVuY3Rpb24gZWxlbWVudERlc2NyaXB0b3JzKGVsOiBJU2ltcGxpZmllZE5vZGUpOiBzdHJpbmdbXSB7XG4gIGxldCBvdXRwdXQ6IHN0cmluZ1tdID0gW11cblxuICBvdXRwdXQucHVzaChlbC50YWcpXG5cbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgaWYgKGVsLmF0dHJzLmtleSkge1xuICAgICAgb3V0cHV0LnB1c2goZWwudGFnICsgJy4nICsgZWwuYXR0cnMua2V5KVxuICAgIH1cbiAgICBpZiAoZWwuYXR0cnMuaWQpIHtcbiAgICAgIG91dHB1dC5wdXNoKGVsLnRhZyArICcjJyArIGVsLmF0dHJzLmlkKVxuICAgIH1cbiAgICBpZiAoZWwuYXR0cnMuc3JjKSB7XG4gICAgICBvdXRwdXQucHVzaChlbC50YWcgKyAnJScgKyBlbC5hdHRycy5zcmMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5mdW5jdGlvbiBmaW5kVW5pcXVlRGVzY3JpcHRvcnMobGlzdDogSVNpbXBsaWZpZWROb2RlW10pIHtcbiAgbGV0IHVuaXF1ZURlc2NyaXB0b3JzID0ge31cbiAgbGV0IGR1cGxpY2F0ZURlc2NyaXB0b3JzID0ge31cbiAgbGV0IG5vZGU6IElTaW1wbGlmaWVkTm9kZVxuICBsZXQgZGVzY3JpcHRvcnM6IHN0cmluZ1tdXG4gIGxldCBkZXNjcmlwdG9yOiBzdHJpbmdcbiAgbGV0IGluVW5pcXVlOiBib29sZWFuXG4gIGxldCBpbkR1cGVzOiBib29sZWFuXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZSA9IGxpc3RbaV1cbiAgICBkZXNjcmlwdG9ycyA9IGVsZW1lbnREZXNjcmlwdG9ycyhub2RlKVxuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBkZXNjcmlwdG9ycy5sZW5ndGg7IGorKykge1xuICAgICAgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JzW2pdXG4gICAgICBpblVuaXF1ZSA9IGRlc2NyaXB0b3IgaW4gdW5pcXVlRGVzY3JpcHRvcnNcbiAgICAgIGluRHVwZXMgPSBkZXNjcmlwdG9yIGluIGR1cGxpY2F0ZURlc2NyaXB0b3JzXG4gICAgICBpZiAoIWluVW5pcXVlICYmICFpbkR1cGVzKSB7XG4gICAgICAgIHVuaXF1ZURlc2NyaXB0b3JzW2Rlc2NyaXB0b3JdID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChpblVuaXF1ZSkge1xuICAgICAgICBkZWxldGUgdW5pcXVlRGVzY3JpcHRvcnNbZGVzY3JpcHRvcl1cbiAgICAgICAgZHVwbGljYXRlRGVzY3JpcHRvcnNbZGVzY3JpcHRvcl0gPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuaXF1ZURlc2NyaXB0b3JzXG59XG5cbmZ1bmN0aW9uIHVuaXF1ZUluQm90aChsMTogSVNpbXBsaWZpZWROb2RlW10sIGwyOiBJU2ltcGxpZmllZE5vZGVbXSkge1xuICBsZXQgbDFVbmlxdWUgPSBmaW5kVW5pcXVlRGVzY3JpcHRvcnMobDEpXG4gIGxldCBsMlVuaXF1ZSA9IGZpbmRVbmlxdWVEZXNjcmlwdG9ycyhsMilcbiAgbGV0IGluQm90aDogeyBbZGVzY3JpcHRvcjogc3RyaW5nXTogYm9vbGVhbiB9ID0ge31cbiAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhsMVVuaXF1ZSlcbiAgbGV0IGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gIGxldCBrZXk6IHN0cmluZ1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldXG4gICAgaWYgKGwyVW5pcXVlW2tleV0pIHtcbiAgICAgIGluQm90aFtrZXldID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbkJvdGhcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRG9uZSh0cmVlOiBJU2ltcGxpZmllZE5vZGUpIHtcbiAgZGVsZXRlIHRyZWVbb3V0ZXJEb25lXVxuICBkZWxldGUgdHJlZVtpbm5lckRvbmVdXG5cbiAgaWYgKHRyZWUuY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gdHJlZS5jaGlsZHJlbi5ldmVyeShyZW1vdmVEb25lKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFcXVhbChlMTogSVNpbXBsaWZpZWROb2RlLCBlMjogSVNpbXBsaWZpZWROb2RlKSB7XG4gIGxldCBlMUF0dHJpYnV0ZXM6IHN0cmluZ1tdXG4gIGxldCBlMkF0dHJpYnV0ZXM6IHN0cmluZ1tdXG5cbiAgaWYgKFxuICAgICFbJ3RhZyddLmV2ZXJ5KGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGlmIChlMVtlbGVtZW50XSAhPT0gZTJbZWxlbWVudF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKEJvb2xlYW4oZTEuYXR0cnMpICE9PSBCb29sZWFuKGUyLmF0dHJzKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKEJvb2xlYW4oZTEuY2hpbGRyZW4pICE9PSBCb29sZWFuKGUyLmNoaWxkcmVuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChlMS5hdHRycykge1xuICAgIGUxQXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGUxLmF0dHJzKVxuICAgIGUyQXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGUyLmF0dHJzKVxuXG4gICAgaWYgKGUxQXR0cmlidXRlcy5sZW5ndGggIT09IGUyQXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoXG4gICAgICAhZTFBdHRyaWJ1dGVzLmV2ZXJ5KGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoIWRlZXBFcXVhbChlMS5hdHRyc1thdHRyaWJ1dGVdLCBlMi5hdHRyc1thdHRyaWJ1dGVdKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIGlmIChlMS5jaGlsZHJlbikge1xuICAgIGlmIChlMS5jaGlsZHJlbi5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKS5sZW5ndGggIT09IGUyLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChcbiAgICAgICFlMS5jaGlsZHJlbi5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKS5ldmVyeShmdW5jdGlvbihjaGlsZE5vZGUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0VxdWFsKGNoaWxkTm9kZSwgZTIuY2hpbGRyZW4uZmlsdGVyKGZpbHRlckhhdmluZ1RhZylbaW5kZXhdKVxuICAgICAgfSlcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHJvdWdobHlFcXVhbChcbiAgZTE6IElTaW1wbGlmaWVkTm9kZSxcbiAgZTI6IElTaW1wbGlmaWVkTm9kZSxcbiAgdW5pcXVlRGVzY3JpcHRvcnM6IHsgW2Rlc2NyaXB0b3I6IHN0cmluZ106IGJvb2xlYW4gfSxcbiAgc2FtZVNpYmxpbmdzOiBib29sZWFuLFxuICBwcmV2ZW50UmVjdXJzaW9uID0gZmFsc2Vcbikge1xuICBsZXQgY2hpbGRVbmlxdWVEZXNjcmlwdG9yczogeyBbZGVzY3JpcHRvcjogc3RyaW5nXTogYm9vbGVhbiB9XG4gIGxldCBub2RlTGlzdDE6IElTaW1wbGlmaWVkTm9kZVtdXG4gIGxldCBub2RlTGlzdDI6IElTaW1wbGlmaWVkTm9kZVtdXG5cbiAgaWYgKCFlMSB8fCAhZTIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChlMS50YWcgIT09IGUyLnRhZykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGUxLnRhZyBpbiB1bmlxdWVEZXNjcmlwdG9ycykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoZTEuYXR0cnMgJiYgZTIuYXR0cnMpIHtcbiAgICBpZiAoZTEuYXR0cnMuaWQpIHtcbiAgICAgIGlmIChlMS5hdHRycy5pZCAhPT0gZTIuYXR0cnMuaWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgaWREZXNjcmlwdG9yID0gZTEudGFnICsgJyMnICsgZTEuYXR0cnMuaWRcbiAgICAgICAgaWYgKGlkRGVzY3JpcHRvciBpbiB1bmlxdWVEZXNjcmlwdG9ycykge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGUxLmF0dHJzLmtleSkge1xuICAgICAgaWYgKGUxLmF0dHJzLmtleSAhPT0gZTIuYXR0cnMua2V5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGtleURlc2NyaXB0b3IgPSBlMS50YWcgKyAnLicgKyBlMS5hdHRycy5rZXlcbiAgICAgICAgaWYgKGtleURlc2NyaXB0b3IgaW4gdW5pcXVlRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlMS5hdHRycy5zcmMpIHtcbiAgICAgIGlmIChlMS5hdHRycy5zcmMgIT09IGUyLmF0dHJzLnNyYykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBrZXlEZXNjcmlwdG9yID0gZTEudGFnICsgJyUnICsgZTEuYXR0cnMuc3JjXG4gICAgICAgIGlmIChrZXlEZXNjcmlwdG9yIGluIHVuaXF1ZURlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzYW1lU2libGluZ3MpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgbm9kZUxpc3QxID0gZTEuY2hpbGRyZW5cbiAgICA/IGUxLmNoaWxkcmVuXG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgOiBbXVxuICBub2RlTGlzdDIgPSBlMi5jaGlsZHJlblxuICAgID8gZTIuY2hpbGRyZW5cbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICA6IFtdXG5cbiAgaWYgKG5vZGVMaXN0MS5sZW5ndGggIT09IG5vZGVMaXN0Mi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChwcmV2ZW50UmVjdXJzaW9uKSB7XG4gICAgcmV0dXJuIG5vZGVMaXN0MS5ldmVyeShmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudGFnID09PSBub2RlTGlzdDJbaW5kZXhdLnRhZ1xuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gbm90ZTogd2Ugb25seSBhbGxvdyBvbmUgbGV2ZWwgb2YgcmVjdXJzaW9uIGF0IGFueSBkZXB0aC4gSWYgJ3ByZXZlbnRSZWN1cnNpb24nXG4gICAgLy8gd2FzIG5vdCBzZXQsIHdlIG11c3QgZXhwbGljaXRseSBmb3JjZSBpdCB0byB0cnVlIGZvciBjaGlsZCBpdGVyYXRpb25zLlxuICAgIGNoaWxkVW5pcXVlRGVzY3JpcHRvcnMgPSB1bmlxdWVJbkJvdGgobm9kZUxpc3QxLCBub2RlTGlzdDIpXG4gICAgcmV0dXJuIG5vZGVMaXN0MS5ldmVyeShmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJvdWdobHlFcXVhbChlbGVtZW50LCBub2RlTGlzdDJbaW5kZXhdLCBjaGlsZFVuaXF1ZURlc2NyaXB0b3JzLCB0cnVlLCB0cnVlKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVPYmo8VD4ob2JqOiBUKTogVCB7XG4gIC8vICBUT0RPOiBEbyB3ZSByZWFsbHkgbmVlZCB0byBjbG9uZSBoZXJlPyBJcyBpdCBub3QgZW5vdWdoIHRvIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbCBvYmplY3Q/XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpXG59XG5cbi8qKlxuICogYmFzZWQgb24gaHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQWxnb3JpdGhtX2ltcGxlbWVudGF0aW9uL1N0cmluZ3MvTG9uZ2VzdF9jb21tb25fc3Vic3RyaW5nI0phdmFTY3JpcHRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vblN1YnNldHMoXG4gIGMxOiBJU2ltcGxpZmllZE5vZGVbXSxcbiAgYzI6IElTaW1wbGlmaWVkTm9kZVtdLFxuICBtYXJrZWQxOiBib29sZWFuW10sXG4gIG1hcmtlZDI6IGJvb2xlYW5bXVxuKTogU3Vic2V0TWFwcGluZyB7XG4gIGxldCBsY3NTaXplID0gMFxuICBsZXQgaW5kZXggPSBbXVxuICBsZXQgYzFMZW5ndGggPSBjMS5sZW5ndGhcbiAgbGV0IGMyTGVuZ3RoID0gYzIubGVuZ3RoXG4gIGxldCBtYXRjaGVzID0gQXJyYXkuYXBwbHkobnVsbCwgbmV3IEFycmF5KGMxTGVuZ3RoICsgMSkpLm1hcChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gW11cbiAgfSlcbiAgLy8gc2V0IHVwIHRoZSBtYXRjaGluZyB0YWJsZVxuICBsZXQgdW5pcXVlRGVzY3JpcHRvcnMgPSB1bmlxdWVJbkJvdGgoYzEsIGMyKVxuICAvLyBJZiBhbGwgb2YgdGhlIGVsZW1lbnRzIGFyZSB0aGUgc2FtZSB0YWcsIGlkIGFuZCBjbGFzcywgdGhlbiB3ZSBjYW5cbiAgLy8gY29uc2lkZXIgdGhlbSByb3VnaGx5IHRoZSBzYW1lIGV2ZW4gaWYgdGhleSBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZlxuICAvLyBjaGlsZHJlbi4gVGhpcyB3aWxsIHJlZHVjZSByZW1vdmluZyBhbmQgcmUtYWRkaW5nIHNpbWlsYXIgZWxlbWVudHMuXG4gIGxldCBzdWJzZXRzU2FtZSA9IGMxTGVuZ3RoID09PSBjMkxlbmd0aFxuICBsZXQgb3JpZ2luXG4gIGxldCByZXRcbiAgbGV0IGMxSW5kZXg6IG51bWJlclxuICBsZXQgYzJJbmRleDogbnVtYmVyXG4gIGxldCBjMUVsZW1lbnQ6IElTaW1wbGlmaWVkTm9kZVxuICBsZXQgYzJFbGVtZW50OiBJU2ltcGxpZmllZE5vZGVcblxuICBpZiAoc3Vic2V0c1NhbWUpIHtcbiAgICBjMS5zb21lKGZ1bmN0aW9uKGVsZW1lbnQsIGkpIHtcbiAgICAgIGxldCBjMURlc2MgPSBlbGVtZW50RGVzY3JpcHRvcnMoZWxlbWVudClcbiAgICAgIGxldCBjMkRlc2MgPSBlbGVtZW50RGVzY3JpcHRvcnMoYzJbaV0pXG4gICAgICBpZiAoYzFEZXNjLmxlbmd0aCAhPT0gYzJEZXNjLmxlbmd0aCkge1xuICAgICAgICBzdWJzZXRzU2FtZSA9IGZhbHNlXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBjMURlc2Muc29tZShmdW5jdGlvbihkZXNjcmlwdGlvbiwgaSkge1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24gIT09IGMyRGVzY1tpXSkge1xuICAgICAgICAgIHN1YnNldHNTYW1lID0gZmFsc2VcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaWYgKCFzdWJzZXRzU2FtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBmaWxsIHRoZSBtYXRjaGVzIHdpdGggZGlzdGFuY2UgdmFsdWVzXG4gIGZvciAoYzFJbmRleCA9IDA7IGMxSW5kZXggPCBjMUxlbmd0aDsgYzFJbmRleCsrKSB7XG4gICAgYzFFbGVtZW50ID0gYzFbYzFJbmRleF1cbiAgICBmb3IgKGMySW5kZXggPSAwOyBjMkluZGV4IDwgYzJMZW5ndGg7IGMySW5kZXgrKykge1xuICAgICAgYzJFbGVtZW50ID0gYzJbYzJJbmRleF1cbiAgICAgIGlmIChcbiAgICAgICAgIW1hcmtlZDFbYzFJbmRleF0gJiZcbiAgICAgICAgIW1hcmtlZDJbYzJJbmRleF0gJiZcbiAgICAgICAgcm91Z2hseUVxdWFsKGMxRWxlbWVudCwgYzJFbGVtZW50LCB1bmlxdWVEZXNjcmlwdG9ycywgc3Vic2V0c1NhbWUpXG4gICAgICApIHtcbiAgICAgICAgbWF0Y2hlc1tjMUluZGV4ICsgMV1bYzJJbmRleCArIDFdID0gbWF0Y2hlc1tjMUluZGV4XVtjMkluZGV4XSA/IG1hdGNoZXNbYzFJbmRleF1bYzJJbmRleF0gKyAxIDogMVxuICAgICAgICBpZiAobWF0Y2hlc1tjMUluZGV4ICsgMV1bYzJJbmRleCArIDFdID49IGxjc1NpemUpIHtcbiAgICAgICAgICBsY3NTaXplID0gbWF0Y2hlc1tjMUluZGV4ICsgMV1bYzJJbmRleCArIDFdXG4gICAgICAgICAgaW5kZXggPSBbYzFJbmRleCArIDEsIGMySW5kZXggKyAxXVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaGVzW2MxSW5kZXggKyAxXVtjMkluZGV4ICsgMV0gPSAwXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGxjc1NpemUgPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgb3JpZ2luID0gW2luZGV4WzBdIC0gbGNzU2l6ZSwgaW5kZXhbMV0gLSBsY3NTaXplXVxuICByZXQgPSBuZXcgU3Vic2V0TWFwcGluZyhvcmlnaW5bMF0sIG9yaWdpblsxXSlcbiAgcmV0Lmxlbmd0aCA9IGxjc1NpemVcblxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogVGhpcyBzaG91bGQgcmVhbGx5IGJlIGEgcHJlZGVmaW5lZCBmdW5jdGlvbiBpbiBBcnJheS4uLlxuICovXG5mdW5jdGlvbiBtYWtlQXJyYXk8VD4objogbnVtYmVyLCB2OiBUKTogVFtdIHtcbiAgcmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIG5ldyBBcnJheShuKSkubWFwKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2XG4gIH0pXG59XG5cbi8qKlxuICogR2VuZXJhdGUgYXJyYXlzIHRoYXQgaW5kaWNhdGUgd2hpY2ggbm9kZSBiZWxvbmdzIHRvIHdoaWNoIHN1YnNldCxcbiAqIG9yIHdoZXRoZXIgaXQncyBhY3R1YWxseSBhbiBvcnBoYW4gbm9kZSwgZXhpc3RpbmcgaW4gb25seSBvbmVcbiAqIG9mIHRoZSB0d28gdHJlZXMsIHJhdGhlciB0aGFuIHNvbWV3aGVyZSBpbiBib3RoLlxuICpcbiAqIFNvIGlmIHQxID0gPGltZz48Y2FudmFzPjxicj4sIHQyID0gPGNhbnZhcz48YnI+PGltZz4uXG4gKiBUaGUgbG9uZ2VzdCBzdWJzZXQgaXMgXCI8Y2FudmFzPjxicj5cIiAobGVuZ3RoIDIpLCBzbyBpdCB3aWxsIGdyb3VwIDAuXG4gKiBUaGUgc2Vjb25kIGxvbmdlc3QgaXMgXCI8aW1nPlwiIChsZW5ndGggMSksIHNvIGl0IHdpbGwgYmUgZ3JvdXAgMS5cbiAqIGdhcHMxIHdpbGwgdGhlcmVmb3JlIGJlIFsxLDAsMF0gYW5kIGdhcHMyIFswLDAsMV0uXG4gKlxuICogSWYgYW4gZWxlbWVudCBpcyBub3QgcGFydCBvZiBhbnkgZ3JvdXAsIGl0IHdpbGwgc3RheSBiZWluZyAndHJ1ZScsIHdoaWNoXG4gKiBpcyB0aGUgaW5pdGlhbCB2YWx1ZS4gRm9yIGV4YW1wbGU6XG4gKiB0MSA9IDxpbWc+PHA+PC9wPjxicj48Y2FudmFzPiwgdDIgPSA8Yj48L2I+PGJyPjxjYW52YXM+PGltZz5cbiAqXG4gKiBUaGUgXCI8cD48L3A+XCIgYW5kIFwiPGI+PC9iPlwiIGRvIG9ubHkgc2hvdyB1cCBpbiBvbmUgb2YgdGhlIHR3byBhbmQgd2lsbFxuICogdGhlcmVmb3JlIGJlIG1hcmtlZCBieSBcInRydWVcIi4gVGhlIHJlbWFpbmluZyBwYXJ0cyBhcmUgcGFydHMgb2YgdGhlXG4gKiBncm91cHMgMCBhbmQgMTpcbiAqIGdhcHMxID0gWzEsIHRydWUsIDAsIDBdLCBnYXBzMiA9IFt0cnVlLCAwLCAwLCAxXVxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0R2FwSW5mb3JtYXRpb24odDE6IElTaW1wbGlmaWVkTm9kZSwgdDI6IElTaW1wbGlmaWVkTm9kZSwgc3RhYmxlOiBTdWJzZXRNYXBwaW5nW10pIHtcbiAgbGV0IGdhcHMxOiAobnVtYmVyIHwgdHJ1ZSlbXSA9IHQxLmNoaWxkcmVuXG4gICAgPyAobWFrZUFycmF5KHQxLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpLmxlbmd0aCwgdHJ1ZSkgYXMgdHJ1ZVtdKVxuICAgIDogW11cbiAgbGV0IGdhcHMyOiAobnVtYmVyIHwgdHJ1ZSlbXSA9IHQyLmNoaWxkcmVuXG4gICAgPyAobWFrZUFycmF5KHQyLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpLmxlbmd0aCwgdHJ1ZSkgYXMgdHJ1ZVtdKVxuICAgIDogW11cbiAgbGV0IGdyb3VwID0gMFxuICBsZXQgbGVuZ3RoID0gc3RhYmxlLmxlbmd0aFxuICBsZXQgaTogbnVtYmVyXG4gIGxldCBqOiBudW1iZXJcbiAgbGV0IGVuZE9sZDogbnVtYmVyXG4gIGxldCBlbmROZXc6IG51bWJlclxuICBsZXQgc3Vic2V0OiBTdWJzZXRNYXBwaW5nXG5cbiAgLy8gZ2l2ZSBlbGVtZW50cyBmcm9tIHRoZSBzYW1lIHN1YnNldCB0aGUgc2FtZSBncm91cCBudW1iZXJcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgc3Vic2V0ID0gc3RhYmxlW2ldXG4gICAgZW5kT2xkID0gc3Vic2V0Lm9sZFZhbHVlICsgc3Vic2V0Lmxlbmd0aFxuICAgIGVuZE5ldyA9IHN1YnNldC5uZXdWYWx1ZSArIHN1YnNldC5sZW5ndGhcbiAgICBmb3IgKGogPSBzdWJzZXQub2xkVmFsdWU7IGogPCBlbmRPbGQ7IGogKz0gMSkge1xuICAgICAgZ2FwczFbal0gPSBncm91cFxuICAgIH1cbiAgICBmb3IgKGogPSBzdWJzZXQubmV3VmFsdWU7IGogPCBlbmROZXc7IGogKz0gMSkge1xuICAgICAgZ2FwczJbal0gPSBncm91cFxuICAgIH1cbiAgICBncm91cCArPSAxXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdhcHMxOiBnYXBzMSxcbiAgICBnYXBzMjogZ2FwczJcbiAgfVxufVxuXG4vKipcbiAqIEZpbmQgYWxsIG1hdGNoaW5nIHN1YnNldHMsIGJhc2VkIG9uIGltbWVkaWF0ZSBjaGlsZCBkaWZmZXJlbmNlcyBvbmx5LlxuICovXG5mdW5jdGlvbiBtYXJrU3ViVHJlZXMob2xkVHJlZTogSVNpbXBsaWZpZWROb2RlLCBuZXdUcmVlOiBJU2ltcGxpZmllZE5vZGUpIHtcbiAgLy8gbm90ZTogdGhlIGNoaWxkIGxpc3RzIGFyZSB2aWV3cywgYW5kIHNvIHVwZGF0ZSBhcyB3ZSB1cGRhdGUgb2xkL25ld1RyZWVcbiAgbGV0IG9sZENoaWxkcmVuID0gb2xkVHJlZS5jaGlsZHJlbiA/IG9sZFRyZWUuY2hpbGRyZW4uZmlsdGVyKGZpbHRlckhhdmluZ1RhZykgOiBbXVxuICBsZXQgbmV3Q2hpbGRyZW4gPSBuZXdUcmVlLmNoaWxkcmVuID8gbmV3VHJlZS5jaGlsZHJlbi5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKSA6IFtdXG4gIGxldCBtYXJrZWQxID0gbWFrZUFycmF5KG9sZENoaWxkcmVuLmxlbmd0aCwgZmFsc2UpXG4gIGxldCBtYXJrZWQyID0gbWFrZUFycmF5KG5ld0NoaWxkcmVuLmxlbmd0aCwgZmFsc2UpXG4gIGxldCBzdWJzZXRzID0gW11cbiAgbGV0IHN1YnNldDogU3Vic2V0TWFwcGluZ1xuICBsZXQgcmV0dXJuSW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzWzFdXG4gIH1cbiAgbGV0IG1hcmtCb3RoID0gZnVuY3Rpb24oaSkge1xuICAgIG1hcmtlZDFbc3Vic2V0Lm9sZFZhbHVlICsgaV0gPSB0cnVlXG4gICAgbWFya2VkMltzdWJzZXQubmV3VmFsdWUgKyBpXSA9IHRydWVcbiAgfVxuICBsZXQgc3Vic2V0QXJyYXk6IG51bWJlcltdXG5cbiAgZG8ge1xuICAgIHN1YnNldCA9IGZpbmRDb21tb25TdWJzZXRzKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgbWFya2VkMSwgbWFya2VkMilcbiAgICBpZiAoc3Vic2V0KSB7XG4gICAgICBzdWJzZXRzLnB1c2goc3Vic2V0KVxuICAgICAgc3Vic2V0QXJyYXkgPSBBcnJheS5hcHBseShudWxsLCBuZXcgQXJyYXkoc3Vic2V0Lmxlbmd0aCkpLm1hcChyZXR1cm5JbmRleClcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzZXRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrQm90aChzdWJzZXRBcnJheVtpXSlcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKHN1YnNldClcbiAgcmV0dXJuIHN1YnNldHNcbn1cblxuZXhwb3J0IGNsYXNzIERpZmZET00ge1xuICB0cmFja2VyOiBEaWZmW11cbiAgdDFPcmlnOiBJU2ltcGxpZmllZE5vZGVcbiAgdDJPcmlnOiBJU2ltcGxpZmllZE5vZGVcbiAgZGVidWcgPSBmYWxzZVxuICBkaWZmY2FwID0gMTAgLy8gTGltaXQgZm9yIGhvdyBtYW55IGRpZmZzIGFyZSBhY2NlcHRpbmcgd2hlbiBkZWJ1Z2dpbmcuIEluYWN0aXZlIHdoZW4gZGVidWcgaXMgZmFsc2UuXG4gIG1heERlcHRoOiBudW1iZXIgfCBmYWxzZSA9IGZhbHNlIC8vIEZhbHNlIG9yIGEgbnVtZXJhbC4gSWYgc2V0IHRvIGEgbnVtZXJhbCwgbGltaXRzIHRoZSBsZXZlbCBvZiBkZXB0aCB0aGF0IHRoZSB0aGUgZGlmZiBtZWNoYW5pc20gbG9va3MgZm9yIGRpZmZlcmVuY2VzLiBJZiBmYWxzZSwgZ29lcyB0aHJvdWdoIHRoZSBlbnRpcmUgdHJlZS5cbiAgbWF4Q2hpbGRDb3VudDogbnVtYmVyIHwgZmFsc2UgPSBmYWxzZSAvLyBGYWxzZSBvciBhIG51bWVyYWwuIElmIHNldCB0byBhIG51bWVyYWwsIGRvZXMgbm90IHRyeSB0byBkaWZmIHRoZSBjb250ZW50cyBvZiBub2RlcyB3aXRoIG1vcmUgY2hpbGRyZW4gaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBtYXhDaGlsZENvdW50RGlmZkNvdW50IGRpZmZlcmVuY2VzIGFtb25nIGNoaWxkIG5vZGVzLlxuICBtYXhDaGlsZENvdW50RGlmZkNvdW50ID0gMyAvLyBOdW1lcmFsLiBTZWUgbWF4Q2hpbGRDb3VudC5cbiAgZmlsdGVyT3V0ZXJEaWZmID0gbnVsbFxuICBjb21wcmVzcyA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IocHVibGljIG9wdGlvbnMgPSB7fSkge31cblxuICAvLyA9PT09PSBDcmVhdGUgYSBkaWZmID09PT09XG5cbiAgZGlmZih0MU5vZGU6IElTaW1wbGlmaWVkTm9kZSwgdDJOb2RlOiBJU2ltcGxpZmllZE5vZGUpOiBEaWZmW10ge1xuICAgIGRpZmZjb3VudCA9IDBcblxuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICB0aGlzLnQxT3JpZyA9IHQxTm9kZVxuICAgICAgdGhpcy50Mk9yaWcgPSB0Mk5vZGVcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrZXIgPSBbXVxuICAgIHJldHVybiB0aGlzLmZpbmREaWZmcyh0MU5vZGUsIHQyTm9kZSlcbiAgfVxuXG4gIGZpbmREaWZmcyh0MTogSVNpbXBsaWZpZWROb2RlLCB0MjogSVNpbXBsaWZpZWROb2RlKTogRGlmZltdIHtcbiAgICBsZXQgZGlmZnM6IERpZmZbXVxuICAgIGRvIHtcbiAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIGRpZmZjb3VudCArPSAxXG4gICAgICAgIGlmIChkaWZmY291bnQgPiB0aGlzLmRpZmZjYXApIHtcbiAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICA7KHdpbmRvdyBhcyBhbnkpLmRpZmZFcnJvciA9IFt0aGlzLnQxT3JpZywgdGhpcy50Mk9yaWddXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdXJwYXNzZWQgZGlmZmNhcDonICsgSlNPTi5zdHJpbmdpZnkodGhpcy50MU9yaWcpICsgJyAtPiAnICsgSlNPTi5zdHJpbmdpZnkodGhpcy50Mk9yaWcpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkaWZmcyA9IHRoaXMuZmluZE5leHREaWZmKHQxLCB0MiwgW10pXG5cbiAgICAgIGlmIChkaWZmcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gTGFzdCBjaGVjayBpZiB0aGUgZWxlbWVudHMgcmVhbGx5IGFyZSB0aGUgc2FtZSBub3cuXG4gICAgICAgIC8vIElmIG5vdCwgcmVtb3ZlIGFsbCBpbmZvIGFib3V0IGJlaW5nIGRvbmUgYW5kIHN0YXJ0IG92ZXIuXG4gICAgICAgIC8vIFNvbWV0aW1lcyBhIG5vZGUgY2FuIGJlIG1hcmtlZCBhcyBkb25lLCBidXQgdGhlIGNyZWF0aW9uIG9mIHN1YnNlcXVlbnQgZGlmZnMgbWVhbnMgdGhhdCBpdCBoYXMgdG8gYmUgY2hhbmdlZCBhZ2Fpbi5cbiAgICAgICAgaWYgKCFpc0VxdWFsKHQxLCB0MikpIHtcbiAgICAgICAgICBpZiAoZm91bmRBbGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHJlbWFpbmluZyBkaWZmcyEnKVxuICAgICAgICAgICAgY29uc29sZS50cmFjZSh7IHQxLCB0MiB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3VuZEFsbCA9IHRydWVcbiAgICAgICAgICAgIHJlbW92ZURvbmUodDEpXG4gICAgICAgICAgICBkaWZmcyA9IHRoaXMuZmluZE5leHREaWZmKHQxLCB0MiwgW10pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlmZnMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3VuZEFsbCA9IGZhbHNlXG4gICAgICAgIHRoaXMudHJhY2tlci5wdXNoKC4uLmRpZmZzKVxuICAgICAgICB0aGlzLmFwcGx5VmlydHVhbCh0MSwgZGlmZnMpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoZGlmZnMubGVuZ3RoID4gMClcbiAgICByZXR1cm4gdGhpcy50cmFja2VyXG4gIH1cblxuICBmaW5kTmV4dERpZmYodDE6IElTaW1wbGlmaWVkTm9kZSwgdDI6IElTaW1wbGlmaWVkTm9kZSwgcm91dGU6IG51bWJlcltdKTogRGlmZltdIHtcbiAgICBsZXQgZGlmZnM6IERpZmZbXVxuICAgIGxldCBmZGlmZnNcblxuICAgIGlmICh0aGlzLm1heERlcHRoICYmIHJvdXRlLmxlbmd0aCA+IHRoaXMubWF4RGVwdGgpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICAvLyBvdXRlciBkaWZmZXJlbmNlcz9cbiAgICBpZiAoIXQxW291dGVyRG9uZV0pIHtcbiAgICAgIGRpZmZzID0gdGhpcy5maW5kT3V0ZXJEaWZmKHQxLCB0Miwgcm91dGUpXG4gICAgICBpZiAodGhpcy5maWx0ZXJPdXRlckRpZmYpIHtcbiAgICAgICAgZmRpZmZzID0gdGhpcy5maWx0ZXJPdXRlckRpZmYodDEsIHQyLCBkaWZmcylcbiAgICAgICAgaWYgKGZkaWZmcykgZGlmZnMgPSBmZGlmZnNcbiAgICAgIH1cbiAgICAgIGlmIChkaWZmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHQxW291dGVyRG9uZV0gPSB0cnVlXG4gICAgICAgIHJldHVybiBkaWZmc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdDFbb3V0ZXJEb25lXSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaW5uZXIgZGlmZmVyZW5jZXM/XG4gICAgaWYgKCF0MVtpbm5lckRvbmVdKSB7XG4gICAgICBkaWZmcyA9IHRoaXMuZmluZElubmVyRGlmZih0MSwgdDIsIHJvdXRlKVxuICAgICAgaWYgKGRpZmZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGRpZmZzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0MVtpbm5lckRvbmVdID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vIGRpZmZlcmVuY2VzXG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgZmluZE91dGVyRGlmZih0MTogSVNpbXBsaWZpZWROb2RlLCB0MjogSVNpbXBsaWZpZWROb2RlLCByb3V0ZTogbnVtYmVyW10pOiBEaWZmW10ge1xuICAgIGxldCBkaWZmczogRGlmZltdID0gW11cbiAgICBsZXQgYXR0clxuICAgIGxldCBhdHRyMVxuICAgIGxldCBhdHRyMlxuICAgIGxldCBhdHRyTGVuZ3RoXG4gICAgbGV0IHBvc1xuICAgIGxldCBpXG5cbiAgICBpZiAodDEudGFnICE9PSB0Mi50YWcpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBEaWZmKClcbiAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5hY3Rpb24sIEFjdGlvbnMucmVwbGFjZUVsZW1lbnQpXG4gICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMub2xkVmFsdWUsIHQxKVxuICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLm5ld1ZhbHVlLCBjbG9uZU9iaih0MikpXG4gICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMucm91dGUsIHJvdXRlKVxuICAgICAgXVxuICAgIH1cblxuICAgIGxldCB0MUNoaWxkcmVuID0gdDEuY2hpbGRyZW4uZmlsdGVyKGZpbHRlckhhdmluZ1RhZylcbiAgICBsZXQgdDJDaGlsZHJlbiA9IHQyLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpXG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm1heENoaWxkQ291bnQgJiZcbiAgICAgIHQxQ2hpbGRyZW4gJiZcbiAgICAgIHQyQ2hpbGRyZW4gJiZcbiAgICAgIHQxQ2hpbGRyZW4ubGVuZ3RoID4gdGhpcy5tYXhDaGlsZENvdW50ICYmXG4gICAgICB0MkNoaWxkcmVuLmxlbmd0aCA+IHRoaXMubWF4Q2hpbGRDb3VudFxuICAgICkge1xuICAgICAgbGV0IGNoaWxkTm9kZXNMZW5ndGggPSB0MUNoaWxkcmVuLmxlbmd0aCA8IHQyQ2hpbGRyZW4ubGVuZ3RoID8gdDFDaGlsZHJlbi5sZW5ndGggOiB0MkNoaWxkcmVuLmxlbmd0aFxuICAgICAgbGV0IGNoaWxkRGlmZkNvdW50ID0gMFxuICAgICAgbGV0IGogPSAwXG4gICAgICB3aGlsZSAoY2hpbGREaWZmQ291bnQgPCB0aGlzLm1heENoaWxkQ291bnREaWZmQ291bnQgJiYgaiA8IGNoaWxkTm9kZXNMZW5ndGgpIHtcbiAgICAgICAgaWYgKCFpc0VxdWFsKHQxQ2hpbGRyZW5bal0sIHQyQ2hpbGRyZW5bal0pKSB7XG4gICAgICAgICAgY2hpbGREaWZmQ291bnQrK1xuICAgICAgICB9XG4gICAgICAgIGorK1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkRGlmZkNvdW50ID09PSB0aGlzLm1heENoaWxkQ291bnREaWZmQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBuZXcgRGlmZigpXG4gICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5hY3Rpb24sIEFjdGlvbnMucmVwbGFjZUVsZW1lbnQpXG4gICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5vbGRWYWx1ZSwgY2xvbmVPYmoodDEpKVxuICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMubmV3VmFsdWUsIGNsb25lT2JqKHQyKSlcbiAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLnJvdXRlLCByb3V0ZSlcbiAgICAgICAgXVxuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHIxID0gdDEuYXR0cnMgPyBPYmplY3Qua2V5cyh0MS5hdHRycykuc29ydCgpIDogW11cbiAgICBhdHRyMiA9IHQyLmF0dHJzID8gT2JqZWN0LmtleXModDIuYXR0cnMpLnNvcnQoKSA6IFtdXG5cbiAgICBhdHRyTGVuZ3RoID0gYXR0cjEubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGF0dHJMZW5ndGg7IGkrKykge1xuICAgICAgYXR0ciA9IGF0dHIxW2ldXG4gICAgICBwb3MgPSBhdHRyMi5pbmRleE9mKGF0dHIpXG4gICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICBkaWZmcy5wdXNoKFxuICAgICAgICAgIG5ldyBEaWZmKClcbiAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLmFjdGlvbiwgQWN0aW9ucy5yZW1vdmVBdHRyaWJ1dGUpXG4gICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5yb3V0ZSwgcm91dGUpXG4gICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5uYW1lLCBhdHRyKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyMi5zcGxpY2UocG9zLCAxKVxuICAgICAgICBpZiAoIWRlZXBFcXVhbCh0MS5hdHRyc1thdHRyXSwgdDIuYXR0cnNbYXR0cl0pKSB7XG4gICAgICAgICAgZGlmZnMucHVzaChcbiAgICAgICAgICAgIG5ldyBEaWZmKClcbiAgICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMuYWN0aW9uLCBBY3Rpb25zLm1vZGlmeUF0dHJpYnV0ZSlcbiAgICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMucm91dGUsIHJvdXRlKVxuICAgICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5uYW1lLCBhdHRyKVxuICAgICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5vbGRWYWx1ZSwgdDEuYXR0cnNbYXR0cl0pXG4gICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLm5ld1ZhbHVlLCB0Mi5hdHRyc1thdHRyXSlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRyTGVuZ3RoID0gYXR0cjIubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGF0dHJMZW5ndGg7IGkrKykge1xuICAgICAgYXR0ciA9IGF0dHIyW2ldXG4gICAgICBkaWZmcy5wdXNoKFxuICAgICAgICBuZXcgRGlmZigpXG4gICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMuYWN0aW9uLCBBY3Rpb25zLmFkZEF0dHJpYnV0ZSlcbiAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5yb3V0ZSwgcm91dGUpXG4gICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMubmFtZSwgYXR0cilcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gZGlmZnNcbiAgfVxuICBmaW5kSW5uZXJEaWZmKHQxOiBJU2ltcGxpZmllZE5vZGUsIHQyOiBJU2ltcGxpZmllZE5vZGUsIHJvdXRlOiBudW1iZXJbXSk6IERpZmZbXSB7XG4gICAgbGV0IHN1YnRyZWVzID0gdDEuY2hpbGRyZW4gJiYgdDIuY2hpbGRyZW4gPyBtYXJrU3ViVHJlZXModDEsIHQyKSA6IFtdXG4gICAgbGV0IHQxQ2hpbGROb2RlcyA9IHQxLmNoaWxkcmVuID8gdDEuY2hpbGRyZW4uZmlsdGVyKGZpbHRlckhhdmluZ1RhZykgOiBbXVxuICAgIGxldCB0MkNoaWxkTm9kZXMgPSB0Mi5jaGlsZHJlbiA/IHQyLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpIDogW11cbiAgICBsZXQgY2hpbGROb2Rlc0xlbmd0aERpZmZlcmVuY2VcbiAgICBsZXQgZGlmZnM6IERpZmZbXSA9IFtdXG4gICAgbGV0IGluZGV4ID0gMFxuICAgIGxldCBsYXN0XG4gICAgbGV0IGUxXG4gICAgbGV0IGUyXG4gICAgbGV0IGlcblxuICAgIGlmIChzdWJ0cmVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAvKiBPbmUgb3IgbW9yZSBncm91cHMgaGF2ZSBiZWVuIGlkZW50aWZpZWQgYW1vbmcgdGhlIGNoaWxkcmVuIG9mIHQxXG4gICAgICAgKiBhbmQgdDIuXG4gICAgICAgKi9cbiAgICAgIGRpZmZzID0gdGhpcy5hdHRlbXB0R3JvdXBSZWxvY2F0aW9uKHQxLCB0Miwgc3VidHJlZXMsIHJvdXRlKVxuICAgICAgaWYgKGRpZmZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGRpZmZzXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogMCBvciAxIGdyb3VwcyBvZiBzaW1pbGFyIGNoaWxkIG5vZGVzIGhhdmUgYmVlbiBmb3VuZFxuICAgICAqIGZvciB0MSBhbmQgdDIuIDEgSWYgdGhlcmUgaXMgMSwgaXQgY291bGQgYmUgYSBzaWduIHRoYXQgdGhlXG4gICAgICogY29udGVudHMgYXJlIHRoZSBzYW1lLiBXaGVuIHRoZSBudW1iZXIgb2YgZ3JvdXBzIGlzIGJlbG93IDIsXG4gICAgICogdDEgYW5kIHQyIGFyZSBtYWRlIHRvIGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFuZCBlYWNoIG9mIHRoZVxuICAgICAqIHBhaXJzIG9mIGNoaWxkIG5vZGVzIGFyZSBkaWZmZWQuXG4gICAgICovXG5cbiAgICBsYXN0ID0gTWF0aC5tYXgodDFDaGlsZE5vZGVzLmxlbmd0aCwgdDJDaGlsZE5vZGVzLmxlbmd0aClcbiAgICBpZiAodDFDaGlsZE5vZGVzLmxlbmd0aCAhPT0gdDJDaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgY2hpbGROb2Rlc0xlbmd0aERpZmZlcmVuY2UgPSB0cnVlXG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxhc3Q7IGkgKz0gMSkge1xuICAgICAgZTEgPSB0MUNoaWxkTm9kZXNbaV1cbiAgICAgIGUyID0gdDJDaGlsZE5vZGVzW2ldXG5cbiAgICAgIGlmIChjaGlsZE5vZGVzTGVuZ3RoRGlmZmVyZW5jZSkge1xuICAgICAgICAvKiB0MSBhbmQgdDIgaGF2ZSBkaWZmZXJlbnQgYW1vdW50cyBvZiBjaGlsZHJlbi4gQWRkXG4gICAgICAgICAqIGFuZCByZW1vdmUgYXMgbmVjZXNzYXJ5IHRvIG9idGFpbiB0aGUgc2FtZSBsZW5ndGggKi9cbiAgICAgICAgaWYgKGUxICYmICFlMikge1xuICAgICAgICAgIGRpZmZzLnB1c2goXG4gICAgICAgICAgICBuZXcgRGlmZigpXG4gICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLmFjdGlvbiwgQWN0aW9ucy5yZW1vdmVFbGVtZW50KVxuICAgICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5yb3V0ZSwgcm91dGUuY29uY2F0KGluZGV4KSlcbiAgICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMuZWxlbWVudCwgZTEpXG4gICAgICAgICAgKVxuICAgICAgICAgIGluZGV4IC09IDFcbiAgICAgICAgfSBlbHNlIGlmIChlMiAmJiAhZTEpIHtcbiAgICAgICAgICBkaWZmcy5wdXNoKFxuICAgICAgICAgICAgbmV3IERpZmYoKVxuICAgICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5hY3Rpb24sIEFjdGlvbnMuYWRkRWxlbWVudClcbiAgICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMucm91dGUsIHJvdXRlLmNvbmNhdChpbmRleCkpXG4gICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLmVsZW1lbnQsIGNsb25lT2JqKGUyKSlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIFdlIGFyZSBub3cgZ3VhcmFudGVlZCB0aGF0IGNoaWxkcmVuIGUxIGFuZCBlMiBleGlzdCxcbiAgICAgICAqIGFuZCB0aGF0IHRoZXkgY2FuIGJlIGRpZmZlZC5cbiAgICAgICAqL1xuICAgICAgLyogRGlmZnMgaW4gY2hpbGQgbm9kZXMgc2hvdWxkIG5vdCBhZmZlY3QgdGhlIHBhcmVudCBub2RlLFxuICAgICAgICogc28gd2UgbGV0IHRoZXNlIGRpZmZzIGJlIHN1Ym1pdHRlZCB0b2dldGhlciB3aXRoIG90aGVyXG4gICAgICAgKiBkaWZmcy5cbiAgICAgICAqL1xuXG4gICAgICBpZiAoZTEgJiYgZTIpIHtcbiAgICAgICAgZGlmZnMgPSBkaWZmcy5jb25jYXQodGhpcy5maW5kTmV4dERpZmYoZTEsIGUyLCByb3V0ZS5jb25jYXQoaW5kZXgpKSlcbiAgICAgIH1cblxuICAgICAgaW5kZXggKz0gMVxuICAgIH1cbiAgICB0MVtpbm5lckRvbmVdID0gdHJ1ZVxuICAgIHJldHVybiBkaWZmc1xuICB9XG5cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1mdW5jdGlvbi1vdmVyLW1ldGhvZFxuICBhdHRlbXB0R3JvdXBSZWxvY2F0aW9uKHQxOiBJU2ltcGxpZmllZE5vZGUsIHQyOiBJU2ltcGxpZmllZE5vZGUsIHN1YnRyZWVzLCByb3V0ZTogbnVtYmVyW10pOiBEaWZmW10ge1xuICAgIC8qIEVpdGhlciB0MS5jaGlsZHJlbiBhbmQgdDIuY2hpbGRyZW4gaGF2ZSB0aGUgc2FtZSBsZW5ndGgsIG9yXG4gICAgICogdGhlcmUgYXJlIGF0IGxlYXN0IHR3byBncm91cHMgb2Ygc2ltaWxhciBlbGVtZW50cyBjYW4gYmUgZm91bmQuXG4gICAgICogYXR0ZW1wdHMgYXJlIG1hZGUgYXQgZXF1YWxpemluZyB0MSB3aXRoIHQyLiBGaXJzdCBhbGwgaW5pdGlhbFxuICAgICAqIGVsZW1lbnRzIHdpdGggbm8gZ3JvdXAgYWZmaWxpYXRpb24gKGdhcHM9dHJ1ZSkgYXJlIHJlbW92ZWQgKGlmXG4gICAgICogb25seSBpbiB0MSkgb3IgYWRkZWQgKGlmIG9ubHkgaW4gdDIpLiBUaGVuIHRoZSBjcmVhdGlvbiBvZiBhIGdyb3VwXG4gICAgICogcmVsb2NhdGlvbiBkaWZmIGlzIGF0dGVtcHRlZC5cbiAgICAqL1xuXG4gICAgbGV0IGdhcEluZm9ybWF0aW9uID0gZ2V0R2FwSW5mb3JtYXRpb24odDEsIHQyLCBzdWJ0cmVlcylcbiAgICBsZXQgZ2FwczEgPSBnYXBJbmZvcm1hdGlvbi5nYXBzMVxuICAgIGxldCBnYXBzMiA9IGdhcEluZm9ybWF0aW9uLmdhcHMyXG4gICAgbGV0IHNob3J0ZXN0ID0gTWF0aC5taW4oZ2FwczEubGVuZ3RoLCBnYXBzMi5sZW5ndGgpXG4gICAgbGV0IGRlc3RpbmF0aW9uRGlmZmVyZW50OiBib29sZWFuXG4gICAgbGV0IHRvR3JvdXBcbiAgICBsZXQgZ3JvdXBcbiAgICBsZXQgbm9kZVxuICAgIGxldCBkaWZmczogRGlmZltdID0gW11cbiAgICBsZXQgaW5kZXgxXG4gICAgbGV0IGluZGV4MlxuICAgIGxldCBqXG5cbiAgICBsZXQgdDFDaGlsZHJlbiA9IHQxLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpXG4gICAgbGV0IHQyQ2hpbGRyZW4gPSB0Mi5jaGlsZHJlbi5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKVxuXG4gICAgZm9yIChpbmRleDIgPSAwLCBpbmRleDEgPSAwOyBpbmRleDIgPCBzaG9ydGVzdDsgaW5kZXgxICs9IDEsIGluZGV4MiArPSAxKSB7XG4gICAgICBpZiAoZ2FwczFbaW5kZXgyXSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlID0gdDFDaGlsZHJlbltpbmRleDFdXG4gICAgICAgIGRpZmZzLnB1c2goXG4gICAgICAgICAgbmV3IERpZmYoKVxuICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMuYWN0aW9uLCBBY3Rpb25zLnJlbW92ZUVsZW1lbnQpXG4gICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5yb3V0ZSwgcm91dGUuY29uY2F0KGluZGV4MikpXG4gICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5lbGVtZW50LCBjbG9uZU9iaihub2RlKSlcbiAgICAgICAgKVxuICAgICAgICBnYXBzMS5zcGxpY2UoaW5kZXgyLCAxKVxuICAgICAgICBzaG9ydGVzdCA9IE1hdGgubWluKGdhcHMxLmxlbmd0aCwgZ2FwczIubGVuZ3RoKVxuICAgICAgICBpbmRleDIgLT0gMVxuICAgICAgfSBlbHNlIGlmIChnYXBzMltpbmRleDJdID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGUgPSB0MkNoaWxkcmVuW2luZGV4Ml1cblxuICAgICAgICBkaWZmcy5wdXNoKFxuICAgICAgICAgIG5ldyBEaWZmKClcbiAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLmFjdGlvbiwgQWN0aW9ucy5hZGRFbGVtZW50KVxuICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMucm91dGUsIHJvdXRlLmNvbmNhdChpbmRleDIpKVxuICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMuZWxlbWVudCwgY2xvbmVPYmoobm9kZSkpXG4gICAgICAgIClcbiAgICAgICAgZ2FwczEuc3BsaWNlKGluZGV4MiwgMCwgdHJ1ZSlcbiAgICAgICAgc2hvcnRlc3QgPSBNYXRoLm1pbihnYXBzMS5sZW5ndGgsIGdhcHMyLmxlbmd0aClcbiAgICAgICAgaW5kZXgxIC09IDFcbiAgICAgIH0gZWxzZSBpZiAoZ2FwczFbaW5kZXgyXSAhPT0gZ2FwczJbaW5kZXgyXSkge1xuICAgICAgICBpZiAoZGlmZnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiBkaWZmc1xuICAgICAgICB9XG4gICAgICAgIC8vIGdyb3VwIHJlbG9jYXRpb25cbiAgICAgICAgZ3JvdXAgPSBzdWJ0cmVlc1tnYXBzMVtpbmRleDJdIGFzIG51bWJlcl1cbiAgICAgICAgdG9Hcm91cCA9IE1hdGgubWluKGdyb3VwLm5ld1ZhbHVlLCB0MUNoaWxkcmVuLmxlbmd0aCAtIGdyb3VwLmxlbmd0aClcbiAgICAgICAgaWYgKHRvR3JvdXAgIT09IGdyb3VwLm9sZFZhbHVlKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBkZXN0aW5hdGlvbiBub2RlcyBhcmUgZGlmZmVyZW50IHRoYW4gb3JpZ2luYXRpbmcgb25lcy5cbiAgICAgICAgICBkZXN0aW5hdGlvbkRpZmZlcmVudCA9IGZhbHNlXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdyb3VwLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIXJvdWdobHlFcXVhbCh0MUNoaWxkcmVuW3RvR3JvdXAgKyBqXSwgdDFDaGlsZHJlbltncm91cC5vbGRWYWx1ZSArIGpdLCB7fSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uRGlmZmVyZW50ID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVzdGluYXRpb25EaWZmZXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIG5ldyBEaWZmKClcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5hY3Rpb24sIEFjdGlvbnMucmVsb2NhdGVHcm91cClcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5ncm91cExlbmd0aCwgZ3JvdXAubGVuZ3RoKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLmZyb20sIGdyb3VwLm9sZFZhbHVlKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLnRvLCB0b0dyb3VwKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLnJvdXRlLCByb3V0ZSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZzXG4gIH1cblxuICAvLyA9PT09PSBBcHBseSBhIHZpcnR1YWwgZGlmZiA9PT09PVxuXG4gIC8qKiBQYXRjaGVzIGEgdmlydHVhbCB0cmVlIHVzaW5nIGEgbGlzdCBvZiBkaWZmcyAqL1xuICBhcHBseVZpcnR1YWwodHJlZTogSVNpbXBsaWZpZWROb2RlLCBkaWZmczogSURpZmZbXSkge1xuICAgIGxldCBsZW5ndGggPSBkaWZmcy5sZW5ndGhcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZGlmZiA9IGRpZmZzW2ldXG4gICAgICB0aGlzLmFwcGx5VmlydHVhbERpZmYodHJlZSwgZGlmZilcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKiBHZXRzIGEgbm9kZSBpbiB0aGUgdmlydHVhbCB0cmVlIGJ5IGEgcm91dGUgKi9cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1mdW5jdGlvbi1vdmVyLW1ldGhvZFxuICBnZXRGcm9tVmlydHVhbFJvdXRlKHRyZWU6IElTaW1wbGlmaWVkTm9kZSwgcm91dGU6IG51bWJlcltdKSB7XG4gICAgbGV0IG5vZGUgPSB0cmVlXG4gICAgbGV0IHBhcmVudE5vZGU6IElTaW1wbGlmaWVkTm9kZVxuICAgIGxldCBub2RlSW5kZXg6IG51bWJlclxuXG4gICAgbGV0IG5ld1JvdXRlID0gcm91dGUuc2xpY2UoKVxuXG4gICAgd2hpbGUgKG5ld1JvdXRlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNoID0gbm9kZS5jaGlsZHJlbi5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKVxuXG4gICAgICBpZiAoIWNoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIG5vZGVJbmRleCA9IG5ld1JvdXRlLnNoaWZ0KClcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlXG4gICAgICBub2RlID0gY2hbbm9kZUluZGV4XVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgICAgIG5vZGVJbmRleDogbm9kZUluZGV4XG4gICAgfVxuICB9XG5cbiAgLyoqIFBhdGNoZXMgYSB2aXJ0dWFsIHRyZWUgdXNpbmcgYSBkaWZmICovXG4gIGFwcGx5VmlydHVhbERpZmYodHJlZTogSVNpbXBsaWZpZWROb2RlLCBkaWZmOiBJRGlmZikge1xuICAgIGxldCByb3V0ZUluZm8gPSB0aGlzLmdldEZyb21WaXJ0dWFsUm91dGUodHJlZSwgZGlmZltBY3Rpb25zLnJvdXRlXSlcbiAgICBsZXQgbm9kZSA9IHJvdXRlSW5mbyAmJiByb3V0ZUluZm8ubm9kZVxuICAgIGxldCBwYXJlbnROb2RlID0gcm91dGVJbmZvICYmIHJvdXRlSW5mby5wYXJlbnROb2RlXG4gICAgbGV0IG5vZGVJbmRleCA9IHJvdXRlSW5mbyAmJiByb3V0ZUluZm8ubm9kZUluZGV4XG4gICAgbGV0IG5ld05vZGU6IElTaW1wbGlmaWVkTm9kZVxuXG4gICAgLy8gcHJlLWRpZmYgaG9va1xuICAgIGxldCBpbmZvID0ge1xuICAgICAgZGlmZjogZGlmZixcbiAgICAgIG5vZGU6IG5vZGUsXG4gICAgICBuZXdOb2RlOiB2b2lkIDBcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGRpZmZbQWN0aW9ucy5hY3Rpb25dKSB7XG4gICAgICBjYXNlIEFjdGlvbnMuYWRkRWxlbWVudDpcbiAgICAgICAgY29uc3Qgcm91dGUgPSBkaWZmW0FjdGlvbnMucm91dGVdLnNsaWNlKClcbiAgICAgICAgY29uc3QgYyA9IHJvdXRlLnNwbGljZShyb3V0ZS5sZW5ndGggLSAxLCAxKVswXVxuICAgICAgICBjb25zdCB4ID0gdGhpcy5nZXRGcm9tVmlydHVhbFJvdXRlKHRyZWUsIHJvdXRlKVxuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgIG5vZGUgPSB4Lm5vZGVcbiAgICAgICAgICBuZXdOb2RlID0gY2xvbmVPYmooZGlmZltBY3Rpb25zLmVsZW1lbnRdKVxuICAgICAgICAgIG5ld05vZGVbb3V0ZXJEb25lXSA9IHRydWVcbiAgICAgICAgICBuZXdOb2RlW2lubmVyRG9uZV0gPSB0cnVlXG5cbiAgICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4gPSBbXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjID49IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoYywgMCwgbmV3Tm9kZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgQWN0aW9ucy5hZGRBdHRyaWJ1dGU6XG4gICAgICAgIGlmICghbm9kZS5hdHRycykge1xuICAgICAgICAgIG5vZGUuYXR0cnMgPSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5hdHRyc1tkaWZmW0FjdGlvbnMubmFtZV1dID0gZGlmZltBY3Rpb25zLnZhbHVlXVxuXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIEFjdGlvbnMubW9kaWZ5QXR0cmlidXRlOlxuICAgICAgICBub2RlLmF0dHJzW2RpZmZbQWN0aW9ucy5uYW1lXV0gPSBkaWZmW0FjdGlvbnMubmV3VmFsdWVdXG5cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgQWN0aW9ucy5yZW1vdmVBdHRyaWJ1dGU6XG4gICAgICAgIGRlbGV0ZSBub2RlLmF0dHJzW2RpZmZbQWN0aW9ucy5uYW1lXV1cblxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBBY3Rpb25zLnJlcGxhY2VFbGVtZW50OlxuICAgICAgICBuZXdOb2RlID0gY2xvbmVPYmooZGlmZltBY3Rpb25zLm5ld1ZhbHVlXSlcbiAgICAgICAgbmV3Tm9kZVtvdXRlckRvbmVdID0gdHJ1ZVxuICAgICAgICBuZXdOb2RlW2lubmVyRG9uZV0gPSB0cnVlXG4gICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbltub2RlSW5kZXhdID0gbmV3Tm9kZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBSZXBsYWNlV2hvbGVUcmVlRXhjZXB0aW9uKClcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBBY3Rpb25zLnJlbG9jYXRlR3JvdXA6XG4gICAgICAgIGNvbnN0IG5vZGVBcnJheSA9IG5vZGUuY2hpbGRyZW4uc3BsaWNlKGRpZmZbQWN0aW9ucy5mcm9tXSwgZGlmZltBY3Rpb25zLmdyb3VwTGVuZ3RoXSkucmV2ZXJzZSgpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoZGlmZltBY3Rpb25zLnRvXSwgMCwgbm9kZUFycmF5W2ldKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIEFjdGlvbnMucmVtb3ZlRWxlbWVudDpcbiAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbi5zcGxpY2Uobm9kZUluZGV4LCAxKVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5sb2coJ3Vua25vd24gYWN0aW9uJylcbiAgICB9XG5cbiAgICAvLyBjYXB0dXJlIG5ld05vZGUgZm9yIHRoZSBjYWxsYmFja1xuICAgIGluZm8ubmV3Tm9kZSA9IG5ld05vZGVcblxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuIl19