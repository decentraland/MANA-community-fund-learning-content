import { ISimplifiedNode, ILand } from '.';
import { DiffPacket } from './internal/types';
export interface ParcelIdentity {
    getParcel(): Promise<{
        x: number;
        y: number;
        land: ILand;
    }>;
}
export interface EntityController {
    /**
     * Overwrites the scene by rendering provided Node
     * @param element
     */
    render(element: ISimplifiedNode | DiffPacket): Promise<void>;
    /**
     * Subscribes to events dispatched by the EntityController
     * Use it to listen to events from the scene (like `click`)
     * @param event
     */
    subscribe(event: string): Promise<void>;
    /**
     * Removes a subscription to an event
     * @param event
     */
    unsubscribe(event: string): Promise<void>;
    /**
     * Passes attributes to the components of an specific entity
     *
     * Values must be specified in the same way as in the Estate definition syntax
     *
     * For example:
     *
     * ```
     * {
     *   position: {x: 0, y:0, z:0},
     *   sound: {src: "sounds/carnivalrides.ogg", autoplay: true }
     *   // etc...
     * }
     * ```
     * @param entityId The value specified in the `id` attribute of the entity
     * @param attributes An object containing attributes and their values as strings
     */
    setEntityAttributes(entityId: string, attributes: {
        [key: string]: any;
    }): Promise<void>;
    /**
     * Returns the value for an especific attribute of an entrity
     * @param entityId The value specified in the `id` attribute of the entity
     * @param attribute The name of the attribute, for example: `position`
     */
    getEntityAttribute(entityId: string, attribute: string): Promise<string>;
    /**
     * Returns the attributes for this script
     *
     * Useful when retrieving attributes passed directly to the `script` entity
     */
    getOwnAttributes(): Promise<{
        [key: string]: any;
    }>;
    /** Event handler for subscription events */
    onSubscribedEvent(fn: any): void;
}
export interface EthereumController {
    /**
     * Use ServiceLocator contract to resolve an contract namespace
     * @param  {string} [namespace] - namespace to resolve
     * @return {string} - Address of the contract
     */
    resolveAddress(namespace: string): Promise<string>;
    /**
     * Check a ERC721 contract for ownership status
     * @param  {string} [ownerAddress] - namespace to resolve
     * @param  {string} [tokenId] - tokenId in the registry contract
     * @param  {string} [registryAddress] - address of the ERC721 DAR.
     * @return {string} - true if provided address is the owner of the asset.
     */
    isOwnerOfCollectible(ownerAddress: string, tokenId: string, registryAddress: string): Promise<boolean>;
    /**
     * Executes a order from the marketplace contract
     * @param  {string} [assetId] - NFT asset id.
     * @param  {number} [amount] - Exact amount of the order.
     * @param  {string} [marketplaceAddress] - Marketplace contract address.
     */
    buyCollectible(assetId: string, amount: number, marketplaceAddress: string): Promise<any>;
    /**
     * Requires a generic payment in ETH or ERC20.
     * @param  {string} [toAddress] - NFT asset id.
     * @param  {number} [amount] - Exact amount of the order.
     * @param  {string} [currency] - ETH or ERC20 supported token symbol
     */
    requirePayment(toAddress: string, amount: number, currency: string): Promise<any>;
    /**
     * Waits for mined transaction.
     * @param  {string} [currency] - Currency used for payment.
     * @param  {string} [txHash] - Transaction hash.
     * @param  {string} [receivingAddress] - Address of the user that receives this payment.
     * @return {any} - Promise of the tx recepit.
     */
    waitForMinedTx(currency: string, txHash: string, receivingAddress: string): Promise<any>;
}
export interface CharactersIdentity {
}
export interface SoundController {
    /**
     * Automatically plays a sound.
     * @param src A path to the sound file relative to the scene directory
     * @param options Additional options shuch as `volume`, and `loop`
     */
    playSound(src: string, options?: {
        volume?: number;
        loop?: boolean;
    }): Promise<void>;
}
export interface UserIdentity {
    getUserPublicKey(): Promise<string>;
}
