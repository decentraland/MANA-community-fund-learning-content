/// <reference types="node" />
import * as JsonRpc2 from './types';
import { EventDispatcher, EventDispatcherBinding } from '../core/EventDispatcher';
export declare abstract class Server<ClientType = any> extends EventDispatcher implements JsonRpc2.IServer {
    sendEncoding: 'JSON' | 'msgpack';
    private _exposedMethodsMap;
    private _consoleLog;
    private _isEnabled;
    readonly isEnabled: boolean;
    constructor(opts?: JsonRpc2.IServerOpts);
    abstract sendMessage(to: ClientType, message: string | Buffer): void;
    abstract getAllClients(): Iterable<ClientType>;
    on(method: 'error', callback: (error: any) => void, once?: boolean): EventDispatcherBinding;
    on(method: string, callback: (params: any, sender: ClientType) => void, once?: boolean): EventDispatcherBinding;
    once(method: 'error', callback: (error: any) => void): EventDispatcherBinding;
    once(method: string, callback: (params: any, sender: ClientType) => void): EventDispatcherBinding;
    setLogging({logConsole}?: JsonRpc2.ILogOpts): void;
    expose(method: string, handler: (...params: any[]) => Promise<any>): void;
    notify(method: string): void;
    notify(method: string, params: string): never;
    notify(method: string, params: number): never;
    notify(method: string, params: boolean): never;
    notify(method: string, params: null): never;
    notify<T>(method: string, params: Iterable<T>): void;
    notify(method: string, params?: Object): void;
    protected enable(): void;
    protected disable(): void;
    protected processMessage(from: ClientType, messageStr: string | Buffer | Uint8Array | number[]): void;
    private _logMessage(messageStr, direction);
    private _send(receiver, message);
    private _sendError(receiver, request, errorCode, error?);
    private _errorFromCode(code, data?, method?);
}
